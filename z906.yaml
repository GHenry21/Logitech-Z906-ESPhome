esphome:
  name: z906
  friendly_name: Logitech Z906

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  reboot_timeout: 0s
  encryption:
    key: !secret api_key

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap: {}

web_server:
  port: 80
  version: 3
  local: True

captive_portal:

# UART configurata per il protocollo Z906
uart:
  id: z906_uart
  tx_pin: GPIO17
  rx_pin: GPIO16
  baud_rate: 57600
  data_bits: 8
  parity: ODD
  stop_bits: 1
#  debug:
#    direction: BOTH

switch:
  - platform: template
    name: "Z906 Power"
    turn_on_action:
       - lambda: |-
          // Flush RX buffer
          while (id(z906_uart).available() > 0) {
            uint8_t dummy;
            id(z906_uart).read_byte(&dummy);
          }
          delay(100);
          // Send ON command
          uint8_t cmd = 0x11;
          id(z906_uart).write_array(&cmd, 1);
          delay(300); // Wait for Z906 to update state
          // Update power state sensor
          id(z906_power_state).update();   
    turn_off_action:
      - lambda: |-
          // Flush RX buffer
          while (id(z906_uart).available() > 0) {
            uint8_t dummy;
            id(z906_uart).read_byte(&dummy);
          }
          delay(100);
          // Send OFF command
          uint8_t cmd = 0x10;
          id(z906_uart).write_array(&cmd, 1);
          delay(300); // Wait for Z906 to update state
          // Reset power-up time and save EEPROM
          uint8_t cmd_save[] = {0x30, 0x37, 0x36};
          id(z906_uart).write_array(cmd_save, sizeof(cmd_save));
          delay(300); // Wait for Z906 to update state
          // Update power state sensor
          id(z906_power_state).update();


button:
  - platform: restart
    name: "Riavvia ESP"

# Input selection buttons
  #input 1 TRS
  - platform: template
    name: "Z906 Input 1 (3.5mm TRS, 6 channels)"
    on_press:
      - lambda: |-
          // Flush RX buffer
          while (id(z906_uart).available() > 0) {
            uint8_t dummy;
            id(z906_uart).read_byte(&dummy);
          }
          delay(100);
          // Sequence: mute, input, effect, unmute
          uint8_t seq[] = {0x09, 0x02, 0x14, 0x08};
          id(z906_uart).write_array(seq, sizeof(seq));
      - delay: 500ms
      - lambda: |-
          id(z906_input_attivo).update();

  # Input 2 (RCA, 2 channels)
  - platform: template
    name: "Z906 Input 2 (RCA, 2 channels)"
    on_press:
      - lambda: |-
          while (id(z906_uart).available() > 0) {
            uint8_t dummy;
            id(z906_uart).read_byte(&dummy);
          }
          delay(500);
          uint8_t seq[] = {0x09, 0x05, 0x16, 0x08};
          id(z906_uart).write_array(seq, sizeof(seq));
      - delay: 500ms
      - lambda: |-
          id(z906_input_attivo).update();

  # Input 3 (Optical)
  - platform: template
    name: "Z906 Input 3 (Optical)"
    on_press:
      - lambda: |-
          while (id(z906_uart).available() > 0) {
            uint8_t dummy;
            id(z906_uart).read_byte(&dummy);
          }
          delay(500);
          uint8_t seq[] = {0x09, 0x03, 0x16, 0x08};
          id(z906_uart).write_array(seq, sizeof(seq));
      - delay: 500ms
      - lambda: |-
          id(z906_input_attivo).update();

  # Input 4 (Optical)
  - platform: template
    name: "Z906 Input 4 (Optical)"
    on_press:
      - lambda: |-
          while (id(z906_uart).available() > 0) {
            uint8_t dummy;
            id(z906_uart).read_byte(&dummy);
          }
          delay(500);
          uint8_t seq[] = {0x09, 0x04, 0x14, 0x08};
          id(z906_uart).write_array(seq, sizeof(seq));
      - delay: 500ms
      - lambda: |-
          id(z906_input_attivo).update();
  # Input 5 (RCA, S/PDIF 75Î© coaxial) (not 100% sure, i cannot test it)
  - platform: template
    name: "Z906 Input 5 (COAXIAL)"
    on_press:
      - lambda: |-
          while (id(z906_uart).available() > 0) {
            uint8_t dummy;
            id(z906_uart).read_byte(&dummy);
          }
          delay(500);
          uint8_t seq[] = {0x09, 0x06, 0x16, 0x08};
          id(z906_uart).write_array(seq, sizeof(seq));
      - delay: 500ms
      - lambda: |-
          id(z906_input_attivo).update();

#VOLUME UP/DOWN
  - platform: template
    name: "VOL+"
    on_press:
     - lambda: |-
        //  Flush RX buffer
        while (id(z906_uart).available() > 0) {
          uint8_t dummy;
          id(z906_uart).read_byte(&dummy); 
        }
        delay(500);
        uint8_t seq[] = {0x08};
        id(z906_uart).write_array(seq, sizeof(seq));
        delay(500);
        // After changing volume, force update of main volume sensor
        id(z906_main_volume).update();


  - platform: template
    name: "VOL-"
    on_press:
     - lambda: |-
        // Flush RX buffer before sending command
        while (id(z906_uart).available() > 0) {
          uint8_t dummy;
          id(z906_uart).read_byte(&dummy);
        }
        delay(500);
        uint8_t seq[] = {0x09};
        id(z906_uart).write_array(seq, sizeof(seq));
        delay(500);
        // After changing volume, force update of main volume sensor
        id(z906_main_volume).update();

#Read full status command
  - platform: template
    name: "Z906 Read Full Status"
    on_press:
      - lambda: |-
          // Flush RX buffer before sending command
          while (id(z906_uart).available() > 0) {
            uint8_t dummy;
            id(z906_uart).read_byte(&dummy);
          }
          delay(500);
          // Send read status command
          uint8_t req = 0x34;
          ESP_LOGI("z906", "Sending read status command: 0x34");
          id(z906_uart).write_array(&req, 1);
          uint32_t start = millis();
          // Wait for at least 23 bytes to arrive
          while (id(z906_uart).available() < 23 && millis() - start < 300) {
            delay(1);
          }
          if (id(z906_uart).available() >= 23) {
            // Find header 0xAA
            while (id(z906_uart).available() >= 23) {
              uint8_t peek;
              id(z906_uart).peek_byte(&peek);
              if (peek == 0xAA) {
                uint8_t dummy;
                id(z906_uart).read_byte(&dummy); // discard 0xAA
                uint8_t resp[22];
                id(z906_uart).read_array(resp, 22);
                ESP_LOGI("z906", "Full Response: AA %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
                  resp[0], resp[1], resp[2], resp[3], resp[4], resp[5], resp[6], resp[7],
                  resp[8], resp[9], resp[10], resp[11], resp[12], resp[13], resp[14], resp[15],
                  resp[16], resp[17], resp[18], resp[19], resp[20], resp[21]);
                break;
              } else {
                uint8_t dummy;
                id(z906_uart).read_byte(&dummy);
              }
            }
          } else {
            ESP_LOGW("z906", "No valid response received from UART.");
          }


sensor:
#power sensor with flush of RX buffer
  - platform: template
    name: "Z906 Power State"
#    internal: true
    id: z906_power_state
    lambda: |-
      // Flush RX buffer before sending command
      while (id(z906_uart).available() > 0) {
        uint8_t dummy;
        id(z906_uart).read_byte(&dummy);
      } 
      uint8_t req[] = {0x34};
      id(z906_uart).write_array(req, sizeof(req));
      uint32_t start = millis();
      // Wait for at least 23 bytes to arrive
      while (id(z906_uart).available() < 23 && millis() - start < 200) {
        delay(1);
      }
      // Find header 0xAA
      while (id(z906_uart).available() >= 23) {
        uint8_t peek;
        id(z906_uart).peek_byte(&peek);
        if (peek == 0xAA) {
          uint8_t dummy;
          id(z906_uart).read_byte(&dummy); // discard 0xAA
          uint8_t resp[22];
          id(z906_uart).read_array(resp, 22);
          // resp[19]: 0x00 ON, 0x01 standby
          return (resp[19] == 0x00) ? 1 : 0;
        } else {
          uint8_t dummy;
          id(z906_uart).read_byte(&dummy);
        }
      }
      return NAN;
    update_interval: never
#input sensor
  - platform: template
    name: "Z906 Input Attivo"
#    internal: true
    id: z906_input_attivo
    lambda: |-
      // Flush RX buffer before sending command
      while (id(z906_uart).available() > 0) {
        uint8_t dummy;
        id(z906_uart).read_byte(&dummy);
      }
      uint8_t req[] = {0x34};
      id(z906_uart).write_array(req, sizeof(req));
      uint32_t start = millis();
      while (id(z906_uart).available() < 23 && millis() - start < 200) {
        delay(1);
      }
      while (id(z906_uart).available() >= 23) {
        uint8_t peek;
        id(z906_uart).peek_byte(&peek);
        if (peek == 0xAA) {
          uint8_t dummy;
          id(z906_uart).read_byte(&dummy); // discard 0xAA
          uint8_t resp[22];
          id(z906_uart).read_array(resp, 22);
          // resp[6] = active input (0 = input 1, 1 = input 2, ... 5 = input 6)
          return resp[6];
        } else {
          uint8_t dummy;
          id(z906_uart).read_byte(&dummy);
        }
      }
      return NAN;
    update_interval: never
#volume sensor
  - platform: template
    name: "Z906 Main Volume"
    internal: true
    id: z906_main_volume
    lambda: |-
     // Flush RX buffer before sending command
      while (id(z906_uart).available() > 0) {
        uint8_t dummy;
        id(z906_uart).read_byte(&dummy);
      }
      uint8_t req[] = {0x34};
      ESP_LOGI("z906", "Sending volume state request: 0x34");
      id(z906_uart).write_array(req, sizeof(req));
      uint32_t start = millis();
      int wait_bytes = 0;
      while (id(z906_uart).available() < 23 && millis() - start < 200) {
        delay(1);
        wait_bytes = id(z906_uart).available();
      }
      ESP_LOGI("z906", "Bytes available after wait: %d", wait_bytes);
      int bytes_checked = 0;
      while (id(z906_uart).available() >= 23) {
        uint8_t peek;
        id(z906_uart).peek_byte(&peek);
        ESP_LOGI("z906", "Peek byte %d: %02X", bytes_checked, peek);
        bytes_checked++;
        if (peek == 0xAA) {
          ESP_LOGI("z906", "Found header 0xAA, reading response...");
          uint8_t dummy;
          id(z906_uart).read_byte(&dummy); // discard 0xAA
          uint8_t resp[22];
          id(z906_uart).read_array(resp, 22);
          ESP_LOGI("z906", "Response: AA %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
            resp[0], resp[1], resp[2], resp[3], resp[4], resp[5], resp[6], resp[7],
            resp[8], resp[9], resp[10], resp[11], resp[12], resp[13], resp[14], resp[15],
            resp[16], resp[17], resp[18], resp[19], resp[20], resp[21]);
          ESP_LOGI("z906", "Main volume (resp[3]): %d", resp[3]);
          return resp[2];
        } else {
          uint8_t dummy;
          id(z906_uart).read_byte(&dummy);
        }
      }
      ESP_LOGW("z906", "No valid response found in UART buffer.");
      return NAN;
    update_interval: never


binary_sensor:
  - platform: template
    name: "Z906 Power State (ON/OFF)"
    lambda: |-
      return id(z906_power_state).state == 1;
    device_class: power
